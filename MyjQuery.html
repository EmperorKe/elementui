<!DOCTYPE html>
<html>
<head> 
	<title></title>
	<meta charset="utf-8">
	<style type="text/css">
/* 	.demo{
	width: 100px;
	height: 100px;
	background-color: red;
} */
	</style>
</head>
<body>
<div class="demo">
</div>
<script type="text/javascript">   
(function(){
	function jQuery(selector){
      return new jQuery.prototype.init(selector);
	}
	jQuery.prototype.init = function(selector){
		this.length = 0;
		//加3种情况，等于null,undefined,或者等于dom
		if(selector==null){ //2个等于就包括了undefined
			return this;
		}
       //选出dom并且包装成jQuery对象返回
       //选id 和class
       if(typeof selector=='string' && selector.indexOf('.')!=-1){ //如果上面代码不是空则是dom，dom没用indexOf要加上判断
       	var dom = document.getElementsByClassName(selector.slice(1));
       }else if(typeof selector=='string' && selector.indexOf('#')!=-1){
       	var dom = document.getElementById(selector.slice(1));
       }
       //判断是否是dom对象
      /* if(selector instanceof Element){
       	     this[0] = selector;
       	     this.length++; */     //如果这段代码成功说明它是dom是一个object，它进不了上面的判断，.length就会报错
     /*  }
*/       if(selector instanceof Element||dom.length==undefined){ //判断是id还是class，因为id没有length;
           this[0] = dom || selector;
           this.length ++;
       }else{
       	 for(var i = 0;i<dom.length;i++){//循环class，都放进this里面
       	 	this[i] = dom[i];        //构造函数有自己的2步在最开头有一个this = {},结尾有一个return this;
       	 	this.length ++;
       	 }
       }
       
	}
	//在原型上定义css
	jQuery.prototype.css = function(config){
		for(var i = 0;i<this.length;i++){ //循环每一个dom，谁调用this，this就指向谁
			for(var prop in config){
				this[i].style[prop] = config[prop]; 
			}
		}
		return this //链式操作 基本上都要返回 return this;
	}
	//原型上赋予css原型
	jQuery.prototype.init.prototype = jQuery.prototype;

     jQuery.prototype.get = function(num){ //get源码
     	if(num!=null){
     		return [].slice.call(this,0);//类数组变成数组
     	}else if(num>=0){ //大于0直接返回调用
     		return this[num];
     	}else{
     		return this[num+this.length] //小于0用公式 假如拿第-1位直接用元素的length加-1；
     	}
     }
 //三目简写 return num!=null?(num>=0?this[num]:this[num+this.length]):[].slice.call(this,0);  
    jQuery.prototype.eq = function(num){
    //dom代表原生dom，它的方法和get一样都是获取元素的第一位区别在于一个是原生的一个是jQuery的，$(demo)这样可以把一个原生变成jQuery。	
    var dom = num!=null?(num>=0?this[num]:this[num+this.length]):null;
          return jQuery(dom); //eq也有prevObject
         /* return this.pushStack(dom);*/
    }  
     
     //写prevObject方法
     jQuery.prototype.pushStack = function(dom){
     	//dom = newObj;
        if(dom.constructor != jQuery){//判断dom是否是jQuery对象
            dom = jQuery(dom);   //不是就让他变成jQuery对象
        }
        dom.prevObject = this;//给dom加上prevObject
        return dom;
     }

    jQuery.prototype.add = function(selector){
        var curObj = jQuery(selector);//add方法就是讲你要写样式的元素合并起来第一把你要合并的样式传进来，
        var baseObj = this;           //把上一个元素也拿进来上一个元素指的就是this，在定义一个空的jQuery
        var newObj = jQuery();        //2个for循环把他们的每个元素挨个传进新的jQuery中，且它的length++,最后返回。
        for(var i = 0;i<curObj.length;i++){
        	newObj[newObj.length++] = curObj[i];
        }
        for(var i = 0;i<baseObj.length;i++){
        	newObj[newObj.length++] = baseObj[i];
        }
       // newObj.prevObject = this;//记录上一个元素
       this.pushStack(newObj);//与上面的函数pushStack产生了关系传的dom就是newObj;
        return newObj;
    }

    jQuery.prototype.end = function(){
          //回退
          return this.prevObject; //直接返回上一个元素
    }


    jQuery.prototype.on = function(type,handle){
          //获取全部的dom
         for(var i = 0;i<this.length;i++){
         	//缓存到这个cacheEvent中，判断如果没有就建立一个cacheEvent
         	if(!this[i].cacheEvent){
         		this[i].cacheEvent = {};
         	}
         	//判断这个dom里的cacheEvent里面是否存了这个事件
         	if(!this[i].cacheEvent[type]){
         		//同一个dom可以同时绑定多个事件
         		this[i].cacheEvent[type] = [handle];
         	}else{
         		//在原有的事件上新加上新的绑定事件
         		this[i].cacheEvent[type].push(handle);
         	}
         }
    }
    jQuery.prototype.trigger = function(type){
    	//判断是否在trigger后面填加了值，有就直接截取，没有就是一个空对象
        var params = arguments.length>1?[].slice.call(arguments,1):[];
        var self = this;
        //获取dom
        for(var i = 0;i<this.length;i++){
          if( this[i].cacheEvent[type] ){
          	this[i].cacheEvent[type].forEach(function(ele,index){
                  ele.apply(self,params);
          	});
          }
        }
    }


    jQuery.prototype.queue = function(type,handle){
        var queueObj = this;
        var queueName = arguments[0] || 'fx';
        var addFunc = arguments[1] || null;
        var len = arguments.length;
        //获取队列
        if(len==1){
        	return queueObj[0][queueName];
        }
        //添加队列或往队列里添加
queueObj[0][queueName]==undefined?queueObj[0][queueName] = [addFunc]:queueObj[0][queueName].push(addFunc);
     return this;
 }
    jQuery.prototype.dequeue = function(type){
    	var self = this;
    	//拿到queue里对应的名称
          var queueName = arguments[0] || 'fx';
          //获取队列数组
          var queueArr = this.queue(queueName);
          //弹出数组
          var currFunc = queueArr.shift();
             if(currFunc==undefined){
             	return;
             }
            
          //递归方式 在执行第一个animate时同时调用第二个
          var next = function(){
           self.dequeue(queueName);
          }
          currFunc(next);
          return this;
    }

    jQuery.prototype.animate = function(json,callback){

      var len = this.length;
      var self = this; //方便使用this  this=jQuery对象
      //最后添加到队列里的内容函数 可以让它运动
      //这个baseFunc是让所有的dom运动且要运动到目标点后执行回调函数
      var baseFunc = function(next){
        var timer = 0;
        for(var i = 0;i<len;i++){
        //取出每个dom,第二个是传目标点，第三个传回调函数  
          starMove(self[i],json,function(){
          timer++;
          if(timer == len ){
            callback && callback();
            next();
          }
          });
        }
      }
   //入队操作
   this.queue('fx',baseFunc);
   if(this.queue('fx').length==1){
    this.dequeue('fx');
   }



      function getStyle(obj,attr){
        if(obj.currentStyle){
          return obj.currentStyle[attr]
        }else{
          return window.getComputedStyle(obj,false)[attr];
        }
      }
      function starMove(obj,json,callback){
        clearInterval(obj.timer);
        var ispeed;
        var iCur;
        var name;
        obj.timer = setInterval(function(){
          var bStop = true;
          for(var attr in json){
            if(attr === 'opacity'){
              name = attr;
              iCur = parseFloat(getStyle(obj,attr))*100;
            }else{
              iCur = parseInt(getStyle(obj,attr));
            }
            iSpeed = (json[attr] - iCur)/7;
            if(iSpeed>0){
              iSpeed = Math.ceil(iSpeed);
            }else{
              iSpeed = Math.floor(iSpeed);
            }
            if(attr === 'opacity'){
              obj.style.opacity = (iCur + iSpeed)/100;
            }else{
              obj.style[attr] = iCur + iSpeed +'px';
            }
            if(json[attr] - iCur !==0){
              bStop = false;
            }
          }
            if(bStop){
              clearInterval(obj.timer);
              callback();
            }
        },30);
      }
      return this;
    } 


   jQuery.prototype.delay = function(time){
     var queueArr = this[0]['fx'];
     queueArr.push(function(next){
     setTimeout(function(){
      next();
       },time);  //delay延迟执行 time表示传的时间
     });
     return this;
   }


    jQuery.Callbacks = function(){
    	//'once'只执行一次,'memory 多次执行', 'once memory',null'
    	var options = arguments[0] || '';//储存参数
      //add方法来储存进来的方法
      var  list = [];
      //记录当前要执行函数的索引
      var fireIndex = 0;
     //记录有没有被fire过
      var fired = false;

      var fire = function(){
       for(;fireIndex<list.length;fireIndex++){
        list[fireIndex].apply(window,args);
       }
       if(options.indexOf('once')!=-1){
        list = [];
        fireIndex = 0;
       }
      }


        //返回2种方法一个add,fire
      return {
      add:function(func){
       list.push(func);//把传的参数push到add里面
       if(options.indexOf('memory')!=-1 && fired){
         fire();
       }
       return this;
        },
        fire:function(){
          fireIndex = 0;
          args = arguments;
          fired = true;
          fire();
        }
      }
         
    }

    jQuery.Deferred = function(){
    	//callbacks,callbacks,callbacks,
    	var arr =[ 
    	[
    	 jQuery.myCallbacks('once memory'),'done','resolve'
    	],[
         jQuery.myCallbacks('once memory'),'fail','reject'
    	],[
         jQuery.myCallbacks('memory'),'progress','notify' 
    	]
      ];
      //注册
      //deferred['done'] = function(){}
      //deferred['fail'] = function(){}
      //deferred['progress'] = function(){}
      var deferred = {};
      var pendding = true;
      for(var i = 0;i<arr.length;i++){
      	deferred[arr[i][1]] = (function(index){
            return function(func){
            arr[index][0].add(func);
          }
      	})(i)
      	//触发
      	//deferred['resolve'] = function(){}
      	//deferred['reject'] = function(){}
      	//deferred['notify'] = function(){}
      	deferred[arr[i][2]] = (function(index){
             return function(){
             	var args = arguments;
             	if(pendding){
             	arr[index][0].fire.apply(window,args);
             	arr[index][2]=='resolve' || arr[index][2]='reject'?pendding = false:'';
             	}
             }
      	})(i);
      }
      return deferred;	
    }

    //$.extend源码 扩展插件 浅层拷贝 深层拷贝
    //never-ending loop 循环引用
    jQuery.extend = jQuery.fn.extend = function(){
    var options,name,src,copy,copyIsArray,clone, //target被操作目标
    target = arguments[0] ||{},                   //扩展 target = this
    i = 1,                                        //浅层 target = arguments[0]
    length = arguments.length,                    //深层 target = arguments[1]
    deep = false;
    if(typeof target === 'boolean'){ //判断target是不是布尔值 true false
       deep = target;                 //true表示是深层拷贝
      target = arguments[i] || {}; //在前面给了一个变量i 因为深层target要等于arguments[1]
      i++;
    }
    if(typeof target!=='object' && !jQuery.isFunction(target)){//如果target不是对象也不是方法
      target = {};//变成空对象，被克隆的必须是对象，方法也是对象
    }
    if(i===length){ //扩展方法 i是等于1的 浅层i等于2 深层i也不等于1 只有扩展只能有一个参数
      target = this;
      i--;
    }
    for(;i<length;i++){
    if((options = arguments[i]) != null){//判断参数是不是空
      for(name in options){
        src = target[name];
        copy = options[name];
        if(target===copy){ //为了防止循环引用
          continue;
        }
        //深层克隆                      对象                                        数组
        if(deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))){
          if(copyIsArray){
             copyIsArray = false;
             clone = src && jQuery.isArray(src) ? src :[]; 
          }else{
            clone = src && jQuery.isPlainObject(src)?src :{};
          }
          target[name] = jQuery.extend(deep,clone,copy);//递归 $.extend(true,obj1,obj2,ob3)
        }else if(copy!==undefined){
          target[name] = copy;
        }
      }
     }
    }
    return target;

    };
    
   
  //init源码
  var rootjQuery,// rootjQuery === $(document)
  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))/$,//匹配<'demo'><'#demo'><'#demo-abs||demo-abs'>
  init = jQuery.fn.init = function(selector,context){
    var match,elem;
    //$(""),$(null),$(undefined),$(false)
    if(!selector){
      return this;
    }
    if(typeof selector === 'string'){
      if(selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length>=3){
        match = [null,selector,null];
      }else{
        match = rquickExpr.exec(selector);//exec==[整体匹配的值，第一个子表达式的值，第二个子表达式的值]
      }                                       //<div/>demo => [<div/>demo,<div/>,undefined]
      if(match && (match[1] || !context)){    //<#demo> => [<#demo>,undefined,demo]
        if(match[1]){
          //创建标签， 判断context 是不是jquery对象 context = {}||JQ
          context = context instanceof jQuery ? context[0] :context;
          //创建任何标签返回jQuery对象中
          jQuery.merge(this,jQuery.parseHTML(
            match[1],
            context && context.nodeType ? context.ownerDocument || context :document,
            true//true表示可以创建任何标签
            ));
          //判断context如果是对象并且标签结构最外侧是一个的
          if(rsingleTag.test(match[1]) && jQuery.isPlainObject(context)){
            for(match in context){              //{html:'duyi',css:{color:'red',dataId:'1001'}}
              if(jQuery.isFunction(this[match])){//判断对象中是否可以直接用html方法，不可以就用
                this[match](context[match]);     //attr来赋值进去
              }else{
                this.attr(match,context[match]);
              }
            }
          }
          return this;
        }else{ //判断id选择器
          elem = document.getElementById(match[2]);
          if(elem && elem.prentNode){
            this.length = 1;
            this[0] = elem;
          }
          this.context = document;//上下文
          this.selector = selector;//dom
          return this;
        }
      }                                        
    }
  } 


	window.$ = window.jQuery = jQuery;
})();
/*$('.demo').css({width:'100px',height:'100px',backgroundColor:'red'})*/
     /*$('.wrapper').add('.demo').css({color:'red'}).end().css({backgroundColor:'black'}); */

/*$('.demo').on('pageLoad',function(a,b,c){
	console.log(a,b,c);
})
$('.demo').trigger('pageLoad',1,2,3);  */


jQuery.prototype.Deferred = function(){
	var arr = [
	[
	jQuery.myCallbacks('once memory'),'done','resolve'
	],
	[
	jQuery.myCallbacks('once memory'),'fail','reject'
	],
	[
	jQuery.myCallbacks('memory'),'progress','notify'
	 ]
	];
	var deferred = {};
	var pendding = true;
	for(var i = 0;i<arr.length;i++){
		deferred[arr[i][1]] = (function(index){
			return function(func){
				arr[index][0].add(func);
			}
		})(i)
		deferred[arr[i][2]] = (function(index){
			return function(){
				if(pendding){
                var args = arguments;
				arr[index][0].fire().apply(window,args);
				arr[index][2]=='resolve'||arr[index][2]=='reject'? pendding=false:'';
				}
			}
		})(i)
	}
	return deferred;
}


jQuery.prototype.on = function(type,handle){
	for(var i = 0;i<this.length;i++){
		if(!this[i].cacheEvent){
			this[i].cacheEvent = {};
		}
		if(!this[i].cacheEvent[type]){
			this[i].cacheEvent[type] = [handle];
		}else{
			this[i].cacheEvent[type].push(handle);
		}
	}
}

jQuery.prototype.trigger = function(type){
	var self = this;
	var params = arguments.length>1?[].slice.call(arguments,1):[];
	for(var i = 0;i<this.length;i++){
		if(this[i].cacheEvent[type]){
			this[i].cacheEvent[type].forEach(function(index,ele){
				ele.apply(params,self);
			})
		}
	}
}

jQuery.prototype.queue = function(type,handle){
	var queueObj = this;
	var queueName = arguments[0] || 'fx';
	var currFunc = arguments[1] || null;
	var len = arguments.length;
	if(len==1){
		return queueObj[0][queueName];
	}
	queue[0][queueName]==undefined?queue[0][queueName] = [currFunc]:queue[0][queueName].push(currFunc);
	return this;
}
jQuery.prototype.dequeue = function(type){
	var queueName = arguments[0] || 'fx';
	var self = this;
	var queueArr = this.queue(queueName);
	var currFunc = queueArr.shift();
	if(currFunc==undefined){
		return;
	}
	var next = function(){
      self.dequeue(queueName)
	}
	currFunc(next);
	return this;
}
jQuery.prototype.on = function(type,handle){
  for(var i = 0;i<this.length;i++){
    if(!this[i].cacheEvent){
      this[i].cacheEvent = {};
    }
    if(!this[i].cacheEvent[type]){
       this[i].cacheEvent[type] = [handle];   
    }else{
      this[i].cacheEvent[type].push(handle);
    }
  }
}
jQuery.prototype.trigger = function(type){
  var params = arguments.length>1?[].slice.call(arguments,1):[];
  var self = this;
  for(var i = 0;i<this.length;i++){
    if(this[i].cacheEvent[type]){
      this[i].cacheEvent[type].forEach(function(index,ele){
         ele.apply(params,self);
      })
    }
  }
}



</script>
</body>
</html>